
{{< include _math.qmd >}}

```{r setup, include=FALSE}
source('_setup.R')
source('rankings.R')
library(gt)
```

# O *ranking* concorda com a lista? Correlações

## Incluindo elementos do *ranking* na lista

### Empatados no final

Elementos do *ranking* que não estão na lista ficam todos empatados no fim da lista.

```{r}
calcular_pos_empate_depois_k <- function(um_rk) {
  
  p <- um_rk$p
  k <- um_rk$k
  
  pos_lista = 1:k
  pos_ranking = um_rk$yes
  
  if (p > k) {
  
    pos_lista <- c(pos_lista,  rep((sum((k+1):p) / (p - k)) , p - k))
    pos_ranking <- c(pos_ranking, um_rk$no)
    
  }

  list(
    pos_lista = pos_lista, 
    pos_ranking = pos_ranking
  )
  
}
```

Exemplo:

```{r echo=TRUE}
calcular_pos_empate_depois_k(rk('x--x-x'))
```


### No final, na ordem inversa

Elementos do *ranking* que não estão na lista ficam no fim da lista, na mesma ordem em que aparecem no *ranking*

```{r}
calcular_pos_em_ordem_depois_k <- function(um_rk) {
  
  p <- um_rk$p
  k <- um_rk$k
  
  pos_lista = 1:k
  pos_ranking = um_rk$yes
  
  if (p > k) {
  
    pos_lista <- c(pos_lista,  p:(k + 1))
    pos_ranking <- c(pos_ranking, um_rk$no)
    
  }

  list(
    pos_lista = pos_lista, 
    pos_ranking = pos_ranking
  )
  
}
```

Exemplo:

```{r echo=TRUE}
calcular_pos_em_ordem_depois_k(rk('x--x-x'))
```

```{r}
exemplos_s <- function(k, maxp, score) {
  
  criar_df_rankings(k = k, maxp = maxp) %>% 
    mutate(s = score(ranking)) %>% 
    arrange(desc(s)) %>% 
    select(ranking_str, s)
  
}
```


## Spearman

### Empatados no final

Uma idéia seria ???

Como são dois vetores de *ranks*, o coeficiente de correlação de Spearman é igual ao de Pearson.

Definimos a função $s()$ para calcular este valor como *score* de um *ranking*.

```{r}
sp1 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_empate_depois_k(um_rk) 
  cor(pos_lista, pos_ranking, method = 'spearman')

}

sp <- function(rk) {

  if (is.rk(rk)) {
    sp1(rk)
  } else {
    rk %>% map_dbl(sp1)
  }

}
```

Como a lista é dada e fixa, só faz sentido, na prática, comparar *rankings* com o mesmo valor de $k$.

A tabela abaixo mostra que usar correlação não faz sentido. Por exemplo, `-xx` recebe um *score* muito pior ($-0{,}5$) do que `-x-------x` ($-0{,}01$):

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = sp
) %>% 
  gt()
```

Devemos abandonar Spearman como medida da qualidade de um *ranking*?

### Em ordem no final

```{r}
sp2 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_em_ordem_depois_k(um_rk) 
  cor(pos_lista, pos_ranking, method = 'spearman')

}

sp_em_ordem <- function(rk) {

  if (is.rk(rk)) {
    sp2(rk)
  } else {
    rk %>% map_dbl(sp2)
  }

}
```

Como a lista é dada e fixa, só faz sentido, na prática, comparar *rankings* com o mesmo valor de $k$.

A tabela abaixo mostra que usar correlação não faz sentido. Por exemplo, `-xx` recebe um *score* muito pior ($-0{,}5$) do que `-x-------x` ($-0{,}01$):

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = sp_em_ordem
) %>% 
  gt()
```



## Kendall

### Empatados no final

O coeficiente de correlação ordinal de Kendall... ???

No R: *When there are ties, Kendall's $\tau_b$ is computed, as proposed by Kendall (1945).*

```{r}
k1 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_empate_depois_k(um_rk) 
  cor(pos_lista, pos_ranking, method = 'kendall')

}

kendall <- function(rk) {

  if (is.rk(rk)) {
    k1(rk)
  } else {
    rk %>% map_dbl(k1)
  }

}
```

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = kendall
) %>% 
  gt()
```

Existem diferenças em relação a Spearman, mas as incoerências persistem.


### Em ordem no final

O coeficiente de correlação ordinal de Kendall... ???

No R: *When there are ties, Kendall's $\tau_b$ is computed, as proposed by Kendall (1945).*

```{r}
k2 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_em_ordem_depois_k(um_rk) 
  cor(pos_lista, pos_ranking, method = 'kendall')

}

kendall_em_ordem <- function(rk) {

  if (is.rk(rk)) {
    k2(rk)
  } else {
    rk %>% map_dbl(k2)
  }

}
```

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = kendall_em_ordem
) %>% 
  gt()
```



## Gama

### Empatados no final

<https://rstudio-pubs-static.s3.amazonaws.com/274882_577e32945b27447a98b1c2ac1dd02adf.html>

```{r}
library(Hmisc)
```

```{r}
g1 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_empate_depois_k(um_rk) 
  rcorr.cens(pos_lista, pos_ranking, outx = TRUE)[[2]]

}

gama <- function(rk) {

  if (is.rk(rk)) {
    g1(rk)
  } else {
    rk %>% map_dbl(g1)
  }

}
```

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = gama
) %>% 
  gt()
```

Nada feito.


### Em ordem no final

```{r}
g2 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_em_ordem_depois_k(um_rk) 
  rcorr.cens(pos_lista, pos_ranking, outx = TRUE)[[2]]

}

gama_em_ordem <- function(rk) {

  if (is.rk(rk)) {
    g2(rk)
  } else {
    rk %>% map_dbl(g2)
  }

}
```

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = gama_em_ordem
) %>% 
  gt()
```



## Covariância das posições

### Empatados no final

Não divide pelo produto dos desvios-padrão.

```{r}
cov1 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_empate_depois_k(um_rk) 
  cov(pos_lista, pos_ranking, method = 'spearman')

}

scov <- function(rk) {

  if (is.rk(rk)) {
    cov1(rk)
  } else {
    rk %>% map_dbl(cov1)
  }

}
```

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = scov
) %>% 
  gt()
```

Nada feito também.


### Em ordem no final

```{r}
cov2 <- function(um_rk) {
  
  c(pos_lista, pos_ranking) %<-% calcular_pos_em_ordem_depois_k(um_rk) 
  cov(pos_lista, pos_ranking, method = 'spearman')

}

scov_em_ordem <- function(rk) {

  if (is.rk(rk)) {
    cov2(rk)
  } else {
    rk %>% map_dbl(cov2)
  }

}
```

```{r}
exemplos_s(
  k = 2, 
  maxp = 10, 
  score = scov_em_ordem
) %>% 
  gt()
```


## Conclusão (?)

Talvez o problema esteja na maneira como estou acomodando os elementos no final da lista.

Pensar a respeito.

