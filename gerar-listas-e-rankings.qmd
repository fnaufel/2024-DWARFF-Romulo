
{{< include _math.qmd >}}

```{r setup, include=FALSE}
source('_setup.R')
library(gt)
```

# Gerar e visualizar exemplos

## Problema

Condições:

* A *expert list* (lista) tem $k$ elementos, $k > 0$, não necessariamente ordenados.

* O *ranking* tem $p$ elementos, $p \geq k$, ordenados, sem empates.

* Todos os elementos da lista estão no *ranking*.

* O último elemento do *ranking* é elemento da lista.

Dadas estas condições, desenvolver funções para

* Criar exemplos com pares de listas e *rankings*, cada par em uma *tibble*.

* Construir tabelas coloridas mostrando as posições dos elementos da lista no *ranking*.

* Calcular diferentes medidas de correlação entre lista e *ranking*.

* Construir gráficos.


## Criando exemplos

### Quantidade de exemplos

Dados $k > 0$ e $p \geq k$ fixos, quantos exemplos existem?

A lista é $L = \{ a_1, \ldots, a_k \}$.

Para montar um *ranking*:

1. Escolher um elemento da lista para ser o último do *ranking*:

   $k$ escolhas.
   
1. Escolher a ordenação dos $k - 1$ elementos restantes da lista:

   $(k - 1)!$ escolhas.
   
1. Escolher as posições dos $k - 1$ elementos restantes da lista dentre as $p - 1$ posições restantes no *ranking*:

   $\binom{p - 1}{k - 1}$ escolhas.
   
Quantidade total de *rankings*:

$$
k \cdot (k - 1)! \cdot \binom{p - 1}{k - 1} 
\quad=\quad
k! \cdot \binom{p - 1}{k - 1}
$$

::: {.callout-note title="Atenção"}

[Os cálculos consideram os $p - k$ elementos do *ranking* que não estão na lista como indistinguíveis]{.hl}. 

Só a presença deles importa, a identidade não.

Veja o exemplo a seguir, onde estes elementos são escritos como "?".

* A lista tem $k = 2$ elementos, chamados de $a$ e $b$.

* O *ranking* tem $p = 4$ elementos.

* Os $6$ *rankings* possíveis são

  * $?\;?\;a\;b$
  * $?\;a\;?\;b$
  * $a\;?\;?\;b$
  * $?\;?\;b\;a$
  * $?\;b\;?\;a$
  * $b\;?\;?\;a$

:::

Quantidades de *rankings*:

```{r cache=TRUE}
df <- expand_grid(
  k = 1:10,
  p = 1:20
) %>% 
  filter(p >= k) %>% 
  mutate(
    exemplos = factorial(k) * choose(p - 1, k - 1)
  )
```

```{r cache=TRUE}
df %>% 
  pivot_wider(
    names_from = k,
    names_sort = TRUE,
    values_from = exemplos,
    values_fill = NA
  ) %>% 
  gt(rowname_col = 'p') %>%
    tab_stubhead(label = md('$p$')) %>% 
    tab_spanner(label = md('$k$'), columns = everything()) %>% 
    fmt_number(sep_mark = '.', dec_mark = ',', decimals = 0) %>% 
    sub_missing(missing_text = '') %>% 
    tab_style(
      cell_text(align = 'left'),
      cells_column_spanners()
    )
```


### Criar uma lista com letras maiúsculas

```{r echo=TRUE}
criar_lista <- function(k) {
  
  stopifnot('Argumento deve ser > 0.' = k > 0)
  sample(LETTERS, k)
  
}
```

```{r echo=TRUE}
criar_lista(10)
```


### Criar um *ranking* a partir de uma lista

A função vai receber a lista, um vetor com as posições dos elementos da lista no *ranking*.

O tamanho $p$ do *ranking* vai ser o maior valor do vetor de posições (já que o último elemento do *ranking* precisa ser da lista).

A função retorna um vetor com o *ranking*, onde os elementos que não estavam na lista são escritos como "?".

```{r echo=TRUE}
criar_ranking <- function(lista, posicoes) {
  
  p <- max(posicoes)
  
  # Verificar se posicoes contêm só números entre 1 e p, sem repetições
  stopifnot(
    'Posições precisam estar entre 1 e p, sem repetições.' =
    all(between(posicoes, 1, p)) & identical(posicoes, unique(posicoes))
  )
  
  ranking <- rep('?', p)
  ranking[posicoes] <- lista
  ranking
  
}
```

```{r echo=TRUE}
r <- criar_ranking(
  LETTERS[1:4],
  c(2, 6, 1, 3)
)

r
```


## Representando um exemplo

### Como *tibble*

Para calcular a correlação entre a lista e o *ranking*, vamos precisar ordenar a lista de alguma forma, pois, se todos os elementos da lista estiverem empatados (i.e., se todos tiverem o mesmo valor de posição), vamos cair em um caso em que o desvio-padrão é $0$ (quando o *ranking* só contiver jogadores da lista).

Dado um *ranking*, a maneira mais conveniente de ordenar a lista afetando a correlação de forma previsível é concordando com o *ranking*!

É isto que esta função faz.

Além disso, os elementos que não estavam na lista mas estão no *ranking*, se existirem, precisam entrar na *tibble*.

Eles vão entrar todos empatados no fim da lista, como no exemplo mais abaixo.

A função retorna uma *tibble* com as colunas `nome`, `pos_lista` e `pos_ranking`.

```{r echo=TRUE}
criar_df <- function(ranking) {
  
  p <- length(ranking)
  lista <- ranking[ranking != '?']
  k <- length(lista)
  pos_lista <- 1:k
  pos_ranking <- which(ranking %in% lista)
  
  # Linhas com elementos da lista
  df <- tibble(
    nome = lista,
    pos_lista = pos_lista,
    pos_ranking = pos_ranking
  )
  
  if (p > k) {
    
    # Linhas com outros elementos
    nomes <- rep('?', p - k)
    pos_lista <- rep((sum((k+1):p) / (p - k)) , p - k)
    pos_ranking <- which(!(ranking %in% lista))
    
    df <- df %>% 
      bind_rows(
        tibble(
          nome = nomes,
          pos_lista = pos_lista,
          pos_ranking = pos_ranking
        )
      )
      
  }
  
  df
  
}
```

```{r echo=TRUE}
r <- criar_ranking(LETTERS[1:4], c(2, 6, 1, 3))
criar_df(r)
```


### Como tabela

Uma maneira mais compacta ainda de representar um exemplo de *ranking*.

```{r echo=TRUE}
criar_tabela <- function(ranking) {
  
  df <- criar_df(ranking) %>%
    select(-pos_lista) %>% 
    arrange(pos_ranking) %>% 
    pivot_wider(
      names_from = pos_ranking,
      values_from = nome
    )

  df %>%
    gt() %>% 
      tab_style(
        cell_fill('red'),
        cells_body(
          columns = where(~ .x == '?')
        )
      )
  
}
```

```{r echo=TRUE}
r <- criar_ranking(LETTERS[1:4], c(2, 6, 1, 3))
criar_tabela(r)
```

Aqui, fica claro quais são e em que posições estão os elementos da lista. 


### Como gráfico

A função recebe um *ranking*, na forma de vetor ou de *tibble*.

A função gera um gráfico de pontos, com um ponto para cada elemento. 

No eixo $x$, a posição do elemento na lista.

No eixo $y$, a posição do elemento no *ranking*.

A função pode receber, além do *ranking*, uma função para calcular o *score* deste *ranking* (i.e., alguma forma de correlação entre o *ranking* e a lista). O *score* vai ser mostrado no título do gráfico.

Opcionalmente, é incluída uma reta de regressão linear via mínimos quadrados.

```{r echo=TRUE}
criar_plot <- function(ranking, fun = NULL, reta = TRUE) {
  
  if (!is_tibble(ranking)) {
    ranking <- criar_df(ranking)
  }
  
  df <- ranking
  p <- nrow(df)
  
  grafico <- df %>% 
    ggplot(aes(pos_lista, pos_ranking)) +
      geom_point() +
      scale_x_continuous(breaks = 1:p, labels = 1:p, limits = c(1, p)) +
      scale_y_continuous(breaks = 1:p, labels = 1:p, limits = c(1, p)) +
      labs(
        x = 'lista',
        y = 'ranking'
      )
  
  if (!is.null(fun)) {
    score <- do.call(fun, list(df))
    grafico <- grafico + labs(title = paste0('Score = ', score))
  }
  
  if (reta) {
    grafico <- grafico +
      geom_smooth(
        formula = y ~ x,
        method = 'lm',
        se = FALSE
      )
  }
  
  grafico

}
```

```{r echo=TRUE}
r <- criar_ranking(LETTERS[1:4], c(2, 6, 1, 3))
```

```{r echo=TRUE}
criar_tabela(r)
```

```{r echo=TRUE}
criar_plot(r)
```

```{r echo=TRUE}
criar_plot(r, reta = FALSE)
```

```{r echo=TRUE}
criar_plot(r, \(df) { cor(df$pos_lista, df$pos_ranking) %>% round(2) })
```

