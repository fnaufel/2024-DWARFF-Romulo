

# Exemplos

```{r}
df %>% 
  ggplot() +
    geom_point(
      aes(k, p, color = exemplos),
      size = 3
    ) +
    scale_color_binned(
      type = 'viridis',
      breaks = c(seq(500, 1000, 250), 1200) * 1e6,
      labels = scales::number_format(scale = 1e-9, suffix = 'B')
    ) +
    scale_x_continuous(breaks = seq(0, 15, 5), limits = c(0, NA))
```

```{r}
df %>% 
  filter(k <= 5, p <= 15) %>% 
  ggplot() +
    geom_point(
      aes(k, p, color = exemplos),
      size = 5
    ) +
    scale_color_binned(
      type = 'gradient',
      breaks = c(seq(0, 5000, 1000)),
    ) +
    scale_x_continuous(breaks = seq(0, 5), limits = c(0, NA)) +
    scale_y_continuous(breaks = 0:15, limits = c(0, NA))
```

```{r}
df %>% 
  filter(k <= 5, p <= 15) %>% 
  ggplot() +
    geom_text(
      aes(k, p, label = exemplos)
    ) +
    scale_x_continuous(breaks = seq(0, 5), limits = c(0, NA)) +
    scale_y_continuous(breaks = 0:15, limits = c(0, NA)) +
    theme(
      panel.grid = element_blank()
    )
```



# Spearman

    geom_abline(linetype = 'dashed', alpha = .3) +


A linha tracejada indica onde todos os pontos deveriam estar para que a concordância entre as duas ordenações fosse perfeita (i.e., $\rho = 1$).

Nããão. Depende dos desvios-padrão.


# Somando -

Dado um *ranking* $r$ com $k$ e $p$, calculamos

$$
s(r) = \frac{\sum_{i = 1, k - 1} i + \operatorname{soma\_}}
  {\sum_{i = 1, p - 1} i}
$$


```{r}
s <- function(ranking) {
  
  if (!is_tibble(ranking)) {
    ranking <- criar_df(ranking)
  }
  
  p <- nrow(ranking)
  
  nomes <- ranking %>% pull(nome)
  k <- sum(nomes == 'x')
  
  soma_k_1 <- sum(1:(k - 1))
  soma_p_1 <- sum(1:(p - 1))
  
  soma_ <- ranking %>% 
    filter(nome == '-') %>% 
    pull(pos_ranking) %>% 
    sum()
  
  (soma_k_1 + soma_) / soma_p_1
  
}

s <- Vectorize(s)
```


```{r}
s <- function(ranking) {
  
  if (!is_tibble(ranking)) {
    ranking <- criar_df(ranking)
  }
  
  p <- nrow(ranking)
  
  nomes <- ranking %>% pull(nome)
  k <- sum(nomes == 'x')
  
  soma_ <- ranking %>% 
    filter(nome == '-') %>% 
    pull(pos_ranking) %>% 
    sum()
  
  (k * (p + 1) + 2 * soma_) / (2 * p * (p + 1))

}


```


# Converter para *tibble*

Para calcular a correlação entre a lista e o *ranking*, vamos precisar ordenar a lista de alguma forma, pois, se todos os elementos da lista estiverem empatados (i.e., se todos tiverem o mesmo valor de posição), vamos cair em um caso em que o desvio-padrão é $0$ (quando o *ranking* só contiver jogadores da lista).

Dado um *ranking*, a maneira mais conveniente de ordenar a lista afetando a correlação de forma previsível é concordando com o *ranking*! Isto vai ficar mais claro mais adiante.

Além disso, os elementos que não estavam na lista mas estão no *ranking*, se existirem, também precisam entrar na *tibble*.

Eles vão entrar todos empatados no fim da lista, como no exemplo mais abaixo.

A função `criar_df()` recebe o *string* correspondente a um *ranking* e retorna uma *tibble* com as colunas `nome`, `pos_lista` e `pos_ranking`.

```{r echo=TRUE}
r = 'x-x-x-xx'
df <- criar_df(r)
df
```

A partir da *tibble*, o *string* do *ranking* pode ser recuperado com

```{r echo=TRUE}
df_string(df)
```


# s

* Vamos escolher $m = 4$. Nossa função fica

  $$
  s(r) = 
    \frac k p + \frac{\operatorname{soma\_}}{2p(p - 1)}
  $$


