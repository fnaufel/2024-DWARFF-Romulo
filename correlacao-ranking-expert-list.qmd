---
title: "Medindo a concordância entre o *ranking* e a *expert list*"
author: "Fernando Náufel"
date: now
date-format: "DD/MM/YYYY HH:mm"
lang: pt

execute: 
  echo: false
  eval: true
  warning: true
  error: true
  include: true

bibliography: bibliography.bib

Português:
csl: universidade-do-porto-faculdade-de-engenharia-chicago-pt-crono.csl

format:
  html:
    toc: true  
    toc-depth: 3
    number-depth: 3
    theme: 
      - journal
      - _custom.scss
    link-external-icon: true
    link-external-newwindow: true
    link-external-filter: ^(?:http:|https:)\/\/fnaufel\.github\.io
    df-print: paged
    code-link: true
    code-copy: true
    code-tools: true
    self-contained: true
---

{{< include _math.qmd >}}

```{r setup, include=FALSE}
source('_setup.R')
set.seed(1237)
```


# Apresentação

???


# *Expert list* como conjunto

Aqui, não existe qualquer ordenação entre os jogadores da *expert list*.


## Exemplo

```{r}
k <- 6
lista <- sample(LETTERS, k)
```

Considere esta *expert list* com $k = `r k`$ jogadores (sem ordem):

```{r}
cat('lista =', lista)
```

Na forma de tabela:

```{r}
df_lista <- tibble(
  jogador = lista,
  rank = sum(1:k)/k
)

df_lista
```

Como não existe ordem na lista, todos os jogadores estão empatados, o que faz com que todos os *ranks* sejam iguais a

$$
\frac{\sum_{i = 1}^{`r k`} i}{`r k`} = `r sum(1:k)/k`
$$

Agora, imagine que temos um *ranking* de todos os $n$ jogadores. Considere o menor prefixo do *ranking* que inclui todos os $k = `r k`$ jogadores da lista (com ordem):

```{r}
# Letras que sobraram
resto <- LETTERS[!(LETTERS %in% lista)]

# Pior posição no ranking de um jogador da lista
p <- 10 

# Escolher outros jogadores para o ranking
outros <- sample(resto, p - k)

# Escolher um jogador da lista para ser o último
# Se o último do ranking não for da lista, este não seria o menor prefixo!
ultimo <- sample(lista, 1)

# Retirar o último da lista
lista_menos_um <- lista[lista != ultimo]

ranking <- c(sample(c(lista_menos_um, outros)), ultimo)
cat('prefixo =', ranking )
```

Este prefixo do *ranking* tem tamanho $p = `r p`$.

Na forma de tabela:

```{r}
df_ranking <- tibble(
  jogador = ranking,
  rank = 1:p
)

df_ranking
```

Para comparar a lista e o prefixo, precisamos que os dois tenham o mesmo tamanho. Vamos adicionar à lista os jogadores que só estão no prefixo, mas estes jogadores terão um *rank* pior do que os que já estavam na lista e, como a lista não "sabe" nada sobre eles, estes jogadores ficarão empatados.

A nova lista fica

```{r}
df_lista_ext <- df_lista %>% 
  bind_rows(
    tibble(
      jogador = outros,
      rank = sum((k + 1):p) / (p - k)
    )
  )

df_lista_ext
```

Agora podemos reunir as informações em uma só tabela:

```{r}
df_comparacao <- df_lista_ext %>% 
  rename(pos_lista = rank) %>% 
  left_join(df_ranking, by = 'jogador') %>% 
  rename(pos_ranking = rank)

df_comparacao
```

O valor do coeficiente de correlação ordinal de Spearman ($\rho$) para estas duas ordenações é simplesmente igual ao coeficiente de correlação linear de Pearson ($r$) entre elas (já que os valores são *ranks*):

```{r}
ro <- with(
  df_comparacao,
  cor(pos_lista, pos_ranking, method = 'spearman')
)

cat('ρ =', ro)
```

No gráfico abaixo, cada ponto representa um jogador:

```{r}
df_comparacao %>% 
  ggplot(aes(pos_lista, pos_ranking)) +
    geom_point() +
    geom_smooth(
      formula = y ~ x,
      method = 'lm',
      se = FALSE
    ) +
    scale_x_continuous(breaks = 1:p, labels = 1:p, limits = c(1, p)) +
    scale_y_continuous(breaks = 1:p, labels = 1:p, limits = c(1, p)) +
    labs(
      x = 'expert list',
      y = 'ranking'
    )
```

```{r}
coef_angular <- 
  ro * sd(df_comparacao$pos_lista) / sd(df_comparacao$pos_ranking)
```

O coeficiente angular $m$ da reta de regressão é proporcional a $\rho$. Mais precisamente,

$$
m =
\rho \cdot \frac{\sigma(\text{ranking})}{\sigma(\text{expert list})}
=
`r ro` \cdot 
\frac{`r sd(df_comparacao$pos_lista)`}
{`r sd(df_comparacao$pos_ranking)`}
= 
`r coef_angular`
$$

## Casos extremos

### Total concordância


### Total discordância


## Casos com mesmo $p$ mas diferentes $\rho$


# *Expert list* como ordem parcial

